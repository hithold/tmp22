Когда мы отсылаем что-то в функцию в качестве аргумента, внутри функции мы сможем работать только с копией этого значения.
Если аргумент - число, то мы можем только использовать его значение, но не изменить значение переданной переменной.
Если аргумент - указатель на число, то мы можем поменять число, но не указатель.
Если аргумент - указатель на массив чисел, то мы можем изменить элементы массива, но не сделать, так чтобы этот указатель был на другую область памяти.

`gcc func.c main.c -o prog` - скомпилировать прогу с функцией вынесенной в файл.

malloc - выделяет кусок памяти и возвращает адрес начала участка памяти.
`#include.h <stdlib.h>` - требуется для использования malloc.
`int *nums;`
`nums = malloc(sizeof(int) * 10 );`
`nums = malloc(sizeof(*nums) * 10 );` - sizeof может понять размер по указателю.
Нужно освобождать память в куче, как можно скорей, если она больше не нужна.
`free (nums);` Это не сотрёт из nums адрес. Но тот участок памяти, уже не будет наш.
Хорошая практика после освобождения памяти, поменять указатель на NULL.

`clang-format -i hello.c` - привести стиль к стандартному формату.


##### Команды препроцессора
Влияют на то, что будет переведено в бинарник.
`cpp main.c` - посмотреть исходник после препроцессора
`#define HELL(x, y) "printf("%d %d",x,y)"` - использование переменных
`#if #elif #else #endif` - условия
`if defined (HELL)` - проверка на существование переменной препроцессора
`gcc main.c -DHELL=1` - задание переменной при компиляции файла
`ifdef HELL` - тоже самое что  и `if defined`. `ifndef HELL` - if not defined
`typedef int * int_pointer;` - определить новый тип - целочисленный указатель
`struct point {int x; int y;};` - объявить новую структуру
`struct point dots[2];` при использовании`dots[0] = dots[1];` скопируются поля примитивных типов, а не указатель на экземпляр. Для ссылочных полей (str) - поинтер.
`dot[0].x = 3;` - доступ к полям.
`(*dot).x = 3;` - ещё вариант обращения к полю. ``
`dot->x=3;` - ещё вариант обращения к полю, оператор стрелки.
`struct Point p3 = {.x = 40, .y = 50};` - явная инициализация по именам полей
`union` - как struct только выделяется место для самого большого типа полей, и храниться может только одно из всех полей union.
Если заполнить какое-то из полей, то он запишется во всё тоже пространство, и затрёт предыдущие байты новым значением в рамках своего размера.


##### Makefile
В этот файл записываются инструкции для сборки проекта с помощью make
`all:`
`gcc main.c -o main`
После имени раздела и двоеточия записываются команды sh.
При запуске make можно передать в параметре название раздела: `make all`
Если какая-то из команд завершается с ошибкой, то сборка прерывается.
`SRCS = main.c hello.c`
`OBJS = ${SRCS:.c=.o}` - встроенная в make функция замены
`hello: ${OBJS}` - собрать .o файлы из .c
`    cc -o hello ${OBJS}`
`all: ` - дефолтное правило.
Когда `make` видит правило, название которого совпадает с целевым файлом, он будет проверять зависимости и временные метки, чтобы определить, нужно ли пересоздавать.

`main.o: main.c header.h` Целью может быть файл main.o. main.c и header.h - тут реквизиты, если один из них новее, чем main.o то цель будет пересоздана нижеследующими командами, с отступом tab.
 Встроенные переменные:
`$<` - эта переменная будет содержать первый реквизит
`$@` - имя файла цели
`$?` - имена реквизитов которые новее чем цель, разделённые пробелами
`.PHONY: all clean install` - указываем фиктивные цели

`%.o: %.c`
`	${CC} -c ${FLAGS} $< -o $@ -I ${H_DIR}` 
Шаблон говорит: _любой файл с расширением `.o` зависит от файла с тем же именем, но с расширением `.c`_.

##### Библиотека
`gcc -c file.c` - создаём .o файлы
`ar rc libstr.a file.o file1.o` - создание библиотеки, важно чтоб имя начиналос c lib
`gсс main.c -L. -lstr` - lstr это (lib)str
`ranlib libstr.a` - создаёт индексы функций, ускоряет компиляцию с этой библиотекой
