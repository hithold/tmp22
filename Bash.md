Шел - это сама CLi bash. А терминал это программа для доступа к ней из GUI.
Среди параметров команд есть options, это зарезервированные слова
Чтобы узнать options можно использовать `--help` или `man` command

- `echo` - выводит строку на консоль. Читается как ЭКО
- `clear` - очистить экран терминала
- `ls -A` - показать список файлов и директорий включая скрытые(имя начинается с точки)
- `wc` - word count.  "-l"  подсчитать кол-во строк(lines), "-w"  подсчитать кол-во слов. При запуске без опций выводит количество строк, слов и символов в файле.

##### Файловая система
- `/` - root - слеш
- `pwd` - print working directory
- `cd -` перейти в предыдущую директорию
- `ll` = ls -l
- абсолютный путь начинается с `/`
- можно использовать автодополнение через нажатие TAB - `cd hom` + tab
- `.` - текущая директория
- `~` -  домашня дирректория пользователя. можно также просто написать cd
- `cd ../../bin` - подняться на два уровня вверх и перейти в bin
- директория пользователей в Mac OS - `Users`, а в Linux - `home`.
##### Переменные
- `VALUE=25 ` - создание переменной VALUE со значением 25
- `echo $VALUE` - использование переменной
- Чтобы присвоить переменной строку нужно использовать одинарные или двойные ковычки.
- При присвоении строки в двойных ковычках можно использовать другие переменные.
- Чтобы дописать в значение переменной строку нужны фигурные скобки для изолирования имени переменной - `VALUE="${VALUE}dobavka"`
- Созданые таким способо переменные - локальные.
- Чтобы сделать глобальную (environment) переменную используется `export VALUE=25 `
- `export` - делает переменную глобальной только в текущем сеансе терминала.
- Для задания глобальных переменных на постоянку, нужно добавить их `export` в `.zshrc`.
- Чтобы увидеть глобальные переменные: `printenv`
- Глобальная переменная `PATH` используется для поиска вводимых shell комманд
- `PATH` содержит пути до директорий с бинарниками разделённые через `:`
- 
##### Чтение файлов
- Для просмотра файла исполььзуются : `cat, nl, head, tail, less`.
- сat - отображает весь файл, nl - с нумерацией по строкам, head и tail - покажут только голову или хвост файла соответствено, less - просмотр файла по чуть-чуть.
- `cat -e` покажет переносы строк в виде доллара
- cat - может нумеровать строки по -b, и может отображать более 1 файла.
- nl - имеет опции не нумеровать пустые строки
- head, tail - показывают только первые/последние 10 стрк, параметр -4 задаст кол-во строк.
- `tail -c 4` - вывести последние 4 символа, включая перенос строки
- `tail -n +2` - вывести все строки начиная со второй до конца файла
- less - позволяет просматривать файл по строчно/по странично

##### Потоки ввода/вывода
У любой команды есть входные параметры и вывод. Команды работают с массивами байт.
Standart input - ввод с клавиатуры.
Standart output - вывод в консоль. 1
Standart error - вывод ошибки в консоль. 2
Также есть input и output из файлов, и в файлы.
`ls 1> output.txt` - направить поток вывода команды в текстовый файл, а не консоль.
`ls 1>> output.txt` - дозаписать вывод комманды в текстовый файл.
`ls 2> error.txt` - направить вывод ошибки в файл, а не консоль.
Можно не указывать 1, т.к. он подразумевается по умолчанию.
`ls > output.txt 2> error.txt` - замена обоих выводов(1,2) на вывод в файлы.
`ls & >> output.txt` - дозаписывать и основной вывод и ошибки в один файл.

##### Файлы конфиграции Shell
 - `bash_profile` или `zprofile` - выполняется при log in
 - `.bashrc` или `.zshrc` - выполняется при открытии shell
rc значит - run commands. Эти файлы запускаются и относятся к конкретному пользователю.
- `echo export VALUE=22 >> .zshrc` - Дозаписывание переменной в rc файл с помощью echo.
- `source .zshrc` или `. ./.zshrc` - выполнит rc файл ещё раз, без перезапуска Shell.

##### Pipe lines или конвееры
Можно использовать вывод одной команды в качестве входных данных для другой, т.к. это всё просто поток байт.
Для перенаправления вывода используется оператор пайп: `|`
- `ls ~ | head -4` - покажет 4 первых строки вывода команды ls

Можно вводить несколько комманд за раз через `;` например:  `cd \ ; ls`
При использовании `;` при ошибке первой команды, вторая всё равно выполнится.
При использовании `&&` последующий команды будут выполняться только если нет ошибок.
При использовании `||` выполняется до первого успешного выполнения. Логическое или.

##### История комманд
История введённых команд хранится в файле .bash_history или .zsh_history
Можно также выполнять поиск по прошлым командам через CTRL-R и ввести часть команды, далее можно перебирать найденное, снова по CTRL-R.
Также есть отдельная команда history, отображающая перечень всех введённых команд.
Можно посмотреть номер команды из history и вызывать её по номеру:  `!58`
`!!`  вызовет предыдущую введённую команду.
Переменная $HISTSIZE в файле .bashrc хранит размер запоминаемого количества комманд.
`history -c`  Очистить историю

##### Директории
`basename`  - предоставляет последнюю часть полного пути до файла
`dirname` - предотавляет полный путь до файла без финальной части
dirname+basename будет полным путём до файла
`mkdir`  - создание директорий. 
`mkdir -p folder/subfolder` - создать сразу дерево директорий
`rmdir` - удаляет пустую папку
`rmdir -p folder/subfolder` - удалит все директории в пути, но только если они без файлов
`rm -r` -рекурсивное удаление не пустой директории

##### Работа с файлами
`cp text.txt text_copy.txt` - копирование с переименованием
`cp text.txt ./docs` - копирование в поддиректорию текущей директории
`cp -f` - параметр force, принудительная замена, даже если есть защита/ошибка
`cp -n` - параметро не перезаписывать существующие файлы.
Если -f стоит после -n или наоборот, то последний параметр "сильнее" 
`cp -i` - запрос о замене каждого существующего файла. Подтверждение - "y" или ввод
`cp -R` - копирует всю директорию со всем содержимым

`mv` - перемещает и/или переименовывает. Использует теже параметры что cp.
`rm -rf` - рекурсивное принудительное удаление

##### inodes
В nix у каждого файла есть уникальный идентификатор inode. Чтобы его увидеть: `ls -i`
В nix есть таблица inode table в которой хранится более подробная мета-информация о каждом файле или директории. Права доступа, даты создания, размер. Доступно по `ls -l`
Также в inode table хранятся адреса на блоки памяти в которых содержится файл.
Можно посмотреть информацию о свободном месте через `df -H -i`

##### Ссылки
Ссылка это альтернативное название файла
Существует два вида ссылок, hardlink и softlink(символический)
- hardlink ссылается на туже строку в inode table. У hardlink ссылки будет такой же id Inode. Нельзя создать на директорию.
- softlink имеет другой inode id. В блоке памяти софтлинка хранится путь до ориг файла. По сути это как shortcut в Windows. Может быть и на директорию.
`ln -s file.txt softlink.txt` - создать софтлинк на файл.
К софтлинку можно обращаться также как к файлу, читать, изменять, это будет обращение к самому файлу. При перемещении/переименовании софтлинк станет сломанным.
`ln file.txt hardlink.txt` - создать хардлинк. Оригинальный файл можно перемещать или переименовывать или изменять, и хардлинк будет работать для изменённого файла.

##### Редактирование файлов
- nano - интуитивно понятный редактор
- vim - расширение от vi
- emacs - обычно не идёт в комплекте с дистрибутивром
В nano:
- сохраниться без выхода CTRL+O,
- прочитать другой файл и добавить его в конец редактируемого CTRL+R
- Выделить можно SHIFT+Стрелочки
- Копировать CTRL+C
- Вырезать CTRL+K
- Вставить  CTRL+U
Vim:
Это mode based text editor. Режим insert, Режим command.
При открытии файла работает command mode. В нём нельзя вводить символы.
Для перехода в insert mode нужно нажать i. Чтобы выйти из него нажимаем ESC.
В command mode комманды вводятся с `:` , но есть и горячие клавиши для правки:
`:w` - запись в файл
`:q!` - выйти без сохранения
`:wq` - выйти с сохранением
`x` - удалить символ
`v` - перейти в режим визуального выделения
`d` - вырезать
`y` - скопирывать
`p`- вставить
`u` - отмена последней правки
`dd` - удаление строки
insertion mode - похож на режим класического редактора

##### File text manipulation
`cut` - извлекает столбец из текстового файла.
`cut -d ";" -f 3-4 file.txt` d - делимитер (разделитель), f - номер колонок для извлечения
`cut -w` - делиметер вайтспейс
`sort` или `sort -r` - отсортировать строки. r - в обратном порядке. Сортирует по словарному
`sort -n` - сортирует как числа, а не строки
`uniq` - оставляет только уникальные строки. `uniq -c` - подсчитать кол-во дубликатов.
`tee output.txt` - записывает в файл, а также передаёт дальше на стандартный вывод 
`tr` - translate characters into other characters
`grep regexp file.txt` - искать строки содержащие заданный паттерн
`grep -v word` - отобразить все строки кроме как содержащие слово
`grep -i WoRd` - искать строки содержащие слово безотносительно его регистра
Без дополнительных параметров grep используется в basic mode. -E позволяет использоваться продвинутые regexp. Тоже самое `egrep` - сразу продвинутый режим.

##### File location commands
`which command` - найти где лежит команда
`type command` - как предыдущая, но ещё распознаёт алиасы
`alias ha='echo ha-ha'` - создать алиас на команду с параметрами, можно вызывать через ha
`whereis command` - ищет команды только в стандартных папках, игнорирую PATH
`locate` - создаёт индекс дерева каталогов, по которому часто ищется, и редко обновляется.
`find` - позволяет искать по дереву каталогов не только по имени, но и по метаинформации.
`find ~ - name "regexp" >2 /dev/null` -  не выводить проверенные пути, которые не содержат паттерн. Параметр `type f` ищет только файлы.
`xargs` - применяет комманды к найденным файлам. `find ~ temp | rm`

##### File Meta-Information
Мета инфомарцию о файлах можно изменять отдельными командами.
`stat file` - display meta-information
`file -i temp` - передаём путь до файла, чтобы узнать тип файла, дирректория, ссылка, файл
`file output` - попробует прочитать и сказать какой формат файла
`du -h` - disk usage human readable - измеряет размер занимаемые файлом/папкой на диске
`du -hs Movies` - покажет общую сумму файлов и директорий в каталоге Movies
`touch` - меняет timestamp. -a access - время доступа, modify - изменение содержимого файла, change - изменение meta-информации о файле даже без изменения его содержимого.
`touch -a file.txt`  - поменять дату доступа на текущую. -m дату изменения на текущую.
`touch newfile.txt` - самый удобный способ создать новый файл

##### Users managment
`whoami` - узнать под каким пользователем ты сейчас
`id` - все пользователи и группы и их id. uid - user id, gid - group id.
`who` - текущие залогиненые пользователи. не работает в wsl, но работает команда w
`useradd` - create account. `userdel` - remove account. `passwd` - change password.
`chsh` - change shell
`chown root file.txt` - change owner на рута. -R - рекурсивно для всех файлов папки

`groups`- отобразить группы моего пользователя.`groups root` - группы в которых состоит рут.
`groupadd` - создание группы, `groupdel` - удаление, `groupmod` - изменение группы.
`chgrp group1 file.txt` - поменять группу к которой принадлежит файл. -R рекурсивно.

##### Permissions
Права к файлам могут быть представлены в трёх видах, восьмеричном 7 7 7, двоичном 101.010.101, либо символьном `rwx r-x r--`. User(u) - Group(g) - Other(o). ещё м.б. ALL(a).
`chmod` изменение прав доступа к файлам. -R рекурсивно.
`chmod u+x` - Добавить(+) права исполнять владельцу(u).
`chmod go-r` Убрать(-) права на чтения группе(g) и отстальным(o).
`chmod a=w` Установить(=) права для всех категорий(a) на запись, а остальные права очистить.
Для захода в дирректорию(открытия файлов и подпапок) нужны права execute. Права read дадут только посмотреть содержимое. Даже если есть все права на файл, он не откроется.
#####  Network Connections
`host google.com` - узнать ip 
`ping` -  проверить доступ к хосту
`traceroute` -  покажет путь до хоста
`ssh -p 2022 ubuntu@localhost "reboot"` - отправить команду reboot на удалённый сервер
Public и Private keys генерируются у себя, а потом паблик кладётся на удалённую машину.
Public ключ копируется в домашний каталог пользователя удалённой машины по пути: 
`~/.ssh/autorized_keys`
`ssh-keygen` - сгенерировать пару ключей
`ssh -i ~/.ssh/id.rsa user@host` - подключиться с помощью приватного ключа.

`scp` - secure copy - используется для копирования файлов между машинами
`scp file.txt ubuntu@host:/home/ubuntu/` - копирование на удалённую с локальной
`scp ubuntu@host:/home/ubuntu/file.txt ~/file.txt` - копирование с удалённой на локальную
`sftp` - тоже для передачи, под копотом использует ssh тоже. Сначала подключиться к хосту, и на нём вводить команды.
`cd` - cd on remote, `lcd` - local cd, `ls` - list remote files, `lls` - list local files, `pwd` - working dir, `lpwd` - local working dir,  `get /remote/file /local/destination` - download, `put` - upload.
В папке .ssh можно создать config с сокращениями. Он состоит из строк, ключ space значение
`Host Oracle` - название алиаса
`HostName 192.168.1.1` - адрес
`Port 22` - порт
`User ubuntu` - пользователь
`IdentityFile ~/.ssh/key` - путь к приватному ключу
Через пустую строку можно писать следующий алиас.
`ssh Oracle` - использование алиаса

##### Scripting
Скрипт может иметь расширение .sh, но может и не иметь его.
`./script.sh` - выполнить. для этого должен быть permission x.
`export PATH=$PATH:$PWD`- добавить текущий каталог со скриптом в PATH чтобы запускать без ./
`#!/bin/bash` - в первой строчке, в комментарии, указывается путь к shell для этого скрипта.
`source script2.sh` - запуск скрипта из скрипта.
`variable="Spring"` Объявление переменной variable.
Типов данных нет. Но не явно, есть строки, целые числа, и boolean(exit-code)
При использовании переменной крайне желательно оборачивать её имя в {}
`echo "${variable}"`

`array=(1 22 42)` - объявление массива
`array[2]=37` - замена 3го элемента массива
`array+=(51 59)` - добавление элементов в конец массива
`echo "${array[1]}"` - выведет второй элемент массива, нумерация с 0
`echo "${array[@]}"` - выведет toString массива
`echo "${#array[@]}"` - выведет размер массива
`read word_var` - прочитать значение из станд. ввода консоли и записать в переменную
###### Подстановки:
`echo {1-9}` - сгенерировать range от 1 до 9.
`rm file{1,2,3}` - удалит файлы с именами file1 file2 file3
`${variable:=default}` - если переменная окажется пустой будет подставлено значение default
`echo $(command)` - подстановка вывода одной команды(в круглых скобах) в другой комманде 
`echo "$((6 * 6 + 4))"` - арифметическое вычисление в двойных круглых скобках(целочислн)
Подстановка в имени файла - `file*` - любые файлы начинающиеся с file. `file?` - один или 0 дополнительных символов, `file[a,b,c]` перечисление - отобразит `filea fileb filec`.
###### Logic
Boolean - 0 это TRUE, всё что не 0 - False
`echo $?` - показать exit-status-code выполнения последней команды. 0 - успешно.
для оценки логического выражения на истинность используется `test`
`test -f file` - проверить существует ли файл. -d директория.
`[[ -d downloads ]]` - более принятая замена команды `test -d downloads`
`test str1 = str2` - проверить строки на равенство
`test n1 -eq n2` - проверить целые числа на равенство, -ne - not equal, -gt - greater, -ge - greater or equal,  -lt - less, -le - less or equal.
`test 2 > 3` - тут сравниваются не числа, а идёт ли строка "2" после строки "3" в словаре.
`(( 2 > 3 ))` - более удобная версия, двойные кругло-скобки без слова test. 
В скобках квадратных или круглых принято использовать пробелы перед и после скобок.
###### Условный оператор
`if (( value > 0 ));  then`
`   echo "${value} is positive"`
`elif (( value == 0 )); then`
`   echo "${value} is zero"`
`else`
`   echo "${value} is negative"`
`fi`
Блоки elif и else не обязательны.
Внутри курглых скобок не нужно использовать оператор обращения к переменной $
###### Case
`echo "Enter command:"`  
`read com`
`case "${com}" in`
`clean)`   // случай clean
`   echo "Running clean"
`   ;;`    //конец блока команд
`build)`
`   echo "Running build"`
`   ;;`
`*)`       // default
`   echo "Command not found"`
`   exit 2`
`   ;;`
`esac`   //закрываем case
###### Циклы
###### While
`counter=10`
`while ((counter>0)); do`
`   echo "Counter value: ${counter}`"
`   (( counter-- ))`
`done`

`until` - тоже самое что while только выполняться будет пока условие ложно.
###### for
`for (( i = 0; i < 5; i++ )); do`
`   echo "index value: ${i}"`
`done`
###### For each
`for n in ${arr1[@]} ; do`
`   echo "$n"`
`done`
###### Функции
`function_name ( ) {
`}
Функцию можно вызывать только после её объявления.
`function_name arg1 arg2 arg3` - при вызове аргументы вызова пишутся через пробел
`$2` - доступ к второму аргументу из тела функции
`$*` или `$@` - доступ ко всем аргум. * - все параметры как одна строка, @ - как массив строк
Можно передавать аргументы и самому скрипту, и также получать к ним доступ.
Функции в bash сделаны не чтобы возвращать что-то, а чтобы исполнять код.
Но они могут вернуть exit-code. По умолчанию неявно возвращается `return 0`. Можно менять его
$? - получить exit-code выполненной функции или последней команды внутри скрипта.
Всё же можно получить какой-то вывод из функции, через использование echo c желаемым выводом в конце функции, а результат принимать с помощью `variable=$(function_name)`.
В bash все переменные функции видны и вне её - в скрипте. Поэтому есть конвенция при объявлении переменных в функции делать это через local - `local var1=12`.

В начале скрипта принято оставлять комментарии о функции скрипта, возможных параметрах его запуска, а также глобальные переменные.

Если скрипт самостоятельный то принято не давать ему расширение. А если скрипт вспомогательный то ему добавляют расширение .sh

`\` - используется в скрипте чтобы продолжить писать команду на новой строчке
